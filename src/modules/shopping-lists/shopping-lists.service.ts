import {
  BadRequestException,
  Injectable,
  NotFoundException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { In, Repository } from 'typeorm';
import { Item } from '../items/entities/item.entity';
import { CreateShoppingListDto } from './dto/create-shopping-list.dto';
import { UpdateShoppingListDto } from './dto/update-shopping-list.dto';
import { UpdateShoppingListStatusDto } from './dto/update-shopping-list-status.dto';
import {
  ShoppingList,
  ShoppingListStatus,
} from './entities/shopping-list.entity';
import { ShoppingListItem } from './entities/shopping-list-item.entity';

@Injectable()
export class ShoppingListsService {
  constructor(
    @InjectRepository(ShoppingList)
    private readonly shoppingListsRepository: Repository<ShoppingList>,
    @InjectRepository(ShoppingListItem)
    private readonly shoppingListItemsRepository: Repository<ShoppingListItem>,
    @InjectRepository(Item)
    private readonly itemsRepository: Repository<Item>,
  ) {}

  async findAll(): Promise<ShoppingList[]> {
    return this.shoppingListsRepository.find();
  }

  async findOne(id: string): Promise<ShoppingList> {
    const list = await this.shoppingListsRepository.findOne({
      where: { id },
    });
    if (!list) {
      throw new NotFoundException(`Shopping list ${id} not found`);
    }
    return list;
  }

  private async ensureItemsExist(
    itemIds: string[],
  ): Promise<Map<string, Item>> {
    const uniqueIds = Array.from(new Set(itemIds));
    const found = uniqueIds.length
      ? await this.itemsRepository.find({ where: { id: In(uniqueIds) } })
      : [];

    if (found.length !== uniqueIds.length) {
      const foundIds = new Set(found.map((item) => item.id));
      const missing = uniqueIds.filter((id) => !foundIds.has(id));
      throw new BadRequestException(`Item(s) not found: ${missing.join(', ')}`);
    }

    return new Map(found.map((item) => [item.id, item]));
  }

  async create(dto: CreateShoppingListDto): Promise<ShoppingList> {
    const itemMap = await this.ensureItemsExist(
      dto.items.map((item) => item.itemId),
    );

    const list = this.shoppingListsRepository.create({
      name: dto.name,
      remarks: dto.remarks ?? null,
      status: 'pending',
      autoGenerated: false,
      items: dto.items.map((itemDto) =>
        this.shoppingListItemsRepository.create({
          item: itemMap.get(itemDto.itemId)!,
          quantity: itemDto.quantity,
          status: itemDto.status ?? 'pending',
          remarks: itemDto.remarks ?? null,
        }),
      ),
    });

    return this.shoppingListsRepository.save(list);
  }

  async update(id: string, dto: UpdateShoppingListDto): Promise<ShoppingList> {
    const list = await this.findOne(id);

    if (list.status === 'completed') {
      throw new BadRequestException(
        'Completed shopping list cannot be modified',
      );
    }

    if (dto.name !== undefined) {
      list.name = dto.name;
    }
    list.remarks = dto.remarks ?? list.remarks;

    if (dto.items) {
      const itemMap = await this.ensureItemsExist(
        dto.items.map((item) => item.itemId),
      );
      await this.shoppingListItemsRepository.delete({ shoppingList: { id } });

      list.items = dto.items.map((itemDto) =>
        this.shoppingListItemsRepository.create({
          shoppingList: list,
          item: itemMap.get(itemDto.itemId)!,
          quantity: itemDto.quantity,
          status: itemDto.status ?? 'pending',
          remarks: itemDto.remarks ?? null,
        }),
      );
    }

    list.status = this.calculateStatus(list.items);

    return this.shoppingListsRepository.save(list);
  }

  async updateStatus(
    id: string,
    dto: UpdateShoppingListStatusDto,
  ): Promise<ShoppingList> {
    const list = await this.findOne(id);
    list.status = dto.status;
    await this.shoppingListsRepository.save(list);
    return this.findOne(id);
  }

  async markItemStatus(
    listId: string,
    itemId: string,
    status: 'pending' | 'purchased',
  ): Promise<ShoppingList> {
    const list = await this.findOne(listId);
    const item = list.items.find((entry) => entry.item.id === itemId);
    if (!item) {
      throw new NotFoundException(
        `Item ${itemId} not found in shopping list ${listId}`,
      );
    }
    item.status = status;
    await this.shoppingListItemsRepository.save(item);

    list.status = this.calculateStatus(list.items);
    await this.shoppingListsRepository.save(list);

    return this.findOne(listId);
  }

  async remove(id: string): Promise<void> {
    const list = await this.findOne(id);
    await this.shoppingListsRepository.remove(list);
  }

  private calculateStatus(items: ShoppingListItem[]): ShoppingListStatus {
    if (!items.length) {
      return 'pending';
    }
    const purchasedCount = items.filter(
      (item) => item.status === 'purchased',
    ).length;

    if (purchasedCount === 0) {
      return 'pending';
    }
    if (purchasedCount === items.length) {
      return 'completed';
    }
    return 'partial';
  }
}
